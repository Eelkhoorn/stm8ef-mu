Date: Tue, 5 Dec 89 13:18:23 MST
From: scott%idacom%watmath@uunet.uu.NET
To: G.Moretti@massey.ac.nz
Status: RO

Dear Giovanni,
	What follows is a nearly completed description of each FORTH word
in the 8051 kernel. Please look it over and send me critisism regarding it.
I'm quite sure there are typing errors and descriptions that are just plain
hard ( or impossible ) to understand. When I find time to finish it I'll send
you a copy.
	Also, I don't mind if the 51-FORTH is distributed around as long as
I am free of liabilities. I consider it public domain and hope that no one
will try to sell it to anyone else. If people want to they can reach me by
email so you can pass on my email address also.


Scott Gehmlich

PS.  My brother and are on our next project: BERT/BLERT for IDACOM's
ISDN Protocol Analyzer.



				Word Description
				 Scott Gehmlich
				   22 Nov 89

Note: 1. All stack references are parameter stack unless otherwise specified.
      2. In cases where 2 stack comments are shown; the first is the compile
         time comment and the second is the run time comment. i.e. IF

( ==== Stack Operators ==== )
SWAP  ( n1 \ n2 -- n2 \ n1 )  exchange top item with 2nd item
DUP  ( n -- n \ n )  duplicate top item
OVER  ( n1 \ n2 -- n1 \ n2 \ n1 )  copy 2nd item over to top item
DROP  ( n -- )  drop top item
NIP  ( n1 \ n2 -- n2 )  drop 2nd item

( ==== Memory primitives ==== )
@   ( a -- n )  fetch word (n) from address (a)
!   ( n \ a -- )  store word (n) at address (a)
C@  ( a -- c )  fetch byte (c) from address (a)
C!  ( c \ a -- )  store byte (c) at address (a)

( ==== Arithmetic operators ==== )
+   ( n1 \ n2 -- n1-n2 )  add top item to 2nd item
-   ( n1 \ n2 -- n1-n2 )  subtract top item from 2nd item
NOT  ( n1 -- _n2 )  invert all bits of top item
AND  ( n1 \ n2 -- n1.and.n2 )  AND top item to 2nd item
OR  ( n1 \ n2 -- n1.or.n2 )  OR top item to 2nd item
XOR  ( n1 \ n2 -- n1.xor.n2 )  XOR top item to 2nd item
2*  ( n -- 2n* )  shift top item left by 1 bit, set bit0 to 0
2/  ( n -- n2/ )  shift top item right by 1 bit, don't change bit15
U2/  ( u -- u2/ )  shift top item right by 1 bit, set bit15 to 0
NEGATE  ( n -- _n )  2's complement of top item
0<  ( n -- flag )  return YES if top item is negative, else return 0

( ==== Return stack primitives ==== )
R>DROP  ( -- )  drop top item of return stack
>R  ( a -- )  move top item to top of return stack
R>  ( -- a )  move top of return stack to top item
R  ( -- a )  copy top of return stack to top item
I  ( -- a )  copy current index of DO-LOOP or FOR-NEXT to top item
DUP>R  ( n -- n )  copy top item to top of return stack

(VAR)  ( -- addr )
(CONST)  ( -- val )

(NEXT)   ( addr -- )

( ==== Control flow primitives ==== )
EXECUTE ( a -- )  execute code at address (a)

@+  ( a -- n\ a+ )  fetch word (n) from address (a), increment (a) by 2
@-  ( a -- n\ a- )  fetch word (n) from address (a), decrement (a) by 2
C@+ ( a -- c\ a+ )  fetch byte (c) from address (a), increment (a) by 1
C@- ( a -- c\ a- )  fetch byte (c) from address (a), decrement (a) by 1
!+  ( n \ a -- a+ )  store word (n) at address (a), increment (a) by 2
!-  ( n \ a -- a- )  store word (n) at address (a), decrement (a) by 2
C!+ ( c \ a -- a+ )  store byte (c) at address (a), increment (a) by 1
C!- ( c \ a -- a- )  store byte (c) at address (a), decrement (a) by 1

TUCK  ( a \ b -- b \ a \ b )  tuck copy of top item under 2nd item
ROT  ( a \ b \ c -- b \ c \ a )  rotate 3rd item to top of stack
2DUP  ( a \ b -- a \ b \ a \ b )  duplicate top 2 items
2DROP  ( a \ b -- )  drop top 2 items
?DUP  ( n -- [n \] n )  if top item is not zero duplicate it, else nothing

( ==== Internal Access ==== )
(IRAM)  ( addr -- )  run time code modifier for BSETI, BCLRI, BCPLI
(IRAMD)  ( addr -- space )  run time code modifier for C@I, B?I
(IRAM2)  ( c \ addr -- )  run time code modifier for C!I

(C@I)  ( addr -- c )  compile time portion of C@I
(C!I)  ( c \ addr -- )  compile time portion of C!I
(BSETI)  ( bit addr -- )  compile time portion of BSETI
(BCLRI)  ( bit addr -- )  compile time portion of BCLRI
(BCPLI)  ( bit addr -- )  compile time portion of BCPLI
(B?I)  ( bit addr -- flag )  compile time portion of B?I

C@I  ( addr -- c )  fetch a byte (c) from address (addr) in 8031
	internal memory space
C!I  ( c \ addr -- )  store a byte (c) at address (addr) in 8031
	internal memory space
BSETI  ( bit addr -- )  set a bit in 8031 internal memory space
BCLRI  ( bit addr -- )  clear a bit in 8031 internal memory space
BCPLI  ( bit addr -- )  complement a bit in 8031 internal memory space
B?I  ( bit addr -- flag )  return a YES if bit in 8031 internal memory
	space is set, else return NO

( ==== Comparison ==== )
 0 CONSTANT NO  returned for false response
-1 CONSTANT YES  returned for true response

<  ( n \ m -- flag )  return YES if 2nd item is less than top item (unsigned)
>  ( n \ m -- flag )  return YES if 2nd item is greater than top
	item (unsigned)
U<  ( n \ m -- flag )  return YES if 2nd item is less than top item (signed)
U>  ( n \ m -- flag )  return YES if 2nd item is greater than top
	item (signed)
0=  ( n -- flag )  return YES if top item equals zero, else return NO
=  ( n \ m -- flag )  return YES if top item equals 2nd item, else return NO

( ==== Memory Manipulation ==== )
20 CONSTANT BL  ascii value for blank

COUNT  ( addr -- addr+ \ count )  move byte at address (addr) to top item
	and add 1 to (addr) and leave as 2nd item
CMOVE  ( src \ dest \ count -- )  move (count) bytes from (src) to (dest)
	from low memory to high memory
<CMOVE  ( src \ dest \ count -- )  move (count) bytes from (src) to (dest)
	from high memory to low memory
MOVE  ( src \ dest \ count -- )  move (count) words from (src) to (dest)
	from high memory to low memory
FILL  ( addr \ count \ char -- )  fill (count) bytes of memory with (char)
	starting at address (addr)
ERASE ( addr \ count -- )  fill (count) bytes of memory with 0
	starting at address (addr)
BLANKS ( addr \ count -- )  fill (count) bytes of memory with 20H 
	starting at address (addr)

( ==== Memory Management ==== )
  origin# CONSTANT dp  dictionary pointer

+!  ( n \ addr -- )  add word (n) to contents of address (addr)

HERE  ( -- addr )  return contents of dp
ALLOT  ( n -- )  allocate n bytes of memory

,  ( n -- )  store word (n) at free memory (HERE), increment dp
C,  ( n -- )  store byte (n) at free memory (HERE), increment dp

1+   ( n1 \ 1+n1 )  add 1 to top item
2+   ( n1 \ 2+n1 )  add 2 to top item

( ==== Header Status Bits ==== )
	   80 CONSTANT #nfa
	   40 CONSTANT #immediate
	   20 CONSTANT #smudge
  origin# 2 + CONSTANT latest

+BITS  ( bits \ addr -- )  set (bits) to 1 at address (addr)
-BITS  ( bits \ addr -- )  set (bits) to 0 at address (addr)

LATEST ( -- nfa )  return nfa of latest compiled word
IMMEDIATE ( -- )  make latest compiled word immediate
SMUDGE    ( -- )  hide latest compiled word from interpreter
RECURSE   ( -- )  reveal latest compiled word to interpreter

( ==== Arithmetic operators ==== )
/MOD  ( n \ m -- r \ q )  divide 2nd item by top item, returning remainder
	as 2nd item and quotient as top item
/  ( n \ m -- quot )  divide 2nd item by top item, returning quotient
	as top item
MOD  ( n \ m -- rem )  divide 2nd item by top item, returning remainder
	as top item

U*  ( n \ m -- nm* )  multiply 2nd item by top item

ABS  ( n -- n )  return absolute value of top item
MAX  ( n \ m -- p )  return max of 2nd item and top item
MIN  ( n \ m -- p )  return min of 2nd item and top item

( ==== State ==== )
 0 VARIABLE compile
C0 CONSTANT #compile	( #nfa #immediate OR )

]  ( -- )  enter compile mode
[  ( -- )  enter interpret mode

( ==== BARON Tasker ==== )
 40 QUEUE peasantq  address of task queue

>Q  ( n \ queue -- )  move 2nd item (n) to next item in (queue)
Q>  ( queue -- n )  move next item in (queue) to top item
Q  ( queue -- n )  return number (n) of items in (queue)

0Q  ( queue -- )  remove all items from (queue)
Q?  ( queue -- n )  return YES if queue is not empty, else return NO

INLINE_NOP  ( -- )  do nothing
INLINE  ( inst -- )  lay down code (inst) inline
BARON  ( -- )  execute a task from the peasant queue

>BARON  ( cfa -- )  add task to peasant queue
KILL  ( cfa -- )  remove all occurances of (cfa) from peasant queue

( ==== Command port primitives ==== )
RX?  ( -- flag )  returns YES if there is a char in the receive buffer
	of 8051 SIO port else returns NO
TX?  ( -- flag )  returns YES if the 8051 SIO port is able to send a char
	else returns NO
TX  ( char -- )  transmits a char out the 8051 SIO port
RX  ( -- char )  accepts a char from the 8051 SIO port

( ==== Sio port servicing ==== )
0 VARIABLE sioa-in	( points to queue used to hold input for port a )
0 VARIABLE sioa-out	( points to queue used to hold output for port a )

SIO-PORTA  ( -- )
POLL-SIO  ( -- )

( ==== Terminal Output ==== )
  0 VARIABLE out
100 QUEUE emitq  ( 256 enough for one string )

?WAIT  ( -- )
EMIT  ( char -- )  emit (char) to screen

CR  ( -- )  emit a carriage return to the screen
SPACE ( -- )  emit a space to the screen
SPACES  ( n -- )  emit (n) spaces to the screen
TYPE ( addr \ count -- )  emit (count) char starting at (addr) to the 
screen

( ==== Numerical Output ==== )
10 VARIABLE base  format of screen output

HEX  ( -- )  set base to HEX
BIN  ( -- )  set base to BINARY
DECIMAL  ( -- )  set base to DECIMAL

PAD ( -- addr )
HOLD  ( char -- )  add (char) to current number string

<#  ( -- )  start number-to-string conversion
#>  ( n -- addr \ count )  end number-to-string conversion returning
	address and length
SIGN  ( m \ n -- n )  add sign (m) to current number string
#  ( n -- n )  convert one digit of (n) and add it to the current
	number string
#S  ( n -- n )  convert all digits on (n) until (n) is 0

DEPTH  ( -- )  save depth of parameter stack in depth
.R  ( n \ m -- )  output (n) to screen right justified to column (m)
.  ( n -- )  emit top item to screen

( ==== Terminal Input ==== )
100 QUEUE keyq   	     ( 256 enough for one string )

KEY?  ( -- flag )  return YES if there is a character from the keyboard to get
KEY   ( -- char )  get a char from the keyboard
 
( ==== Parser ==== )
  0 VARIABLE tib  52 TALLOT  ( tib points to terminal input buffer )
  0 VARIABLE in		     ( index into TIB )

INPUT  ( -- addr )  return current address within input buffer
+IN  ( addr -- )  increment input buffer pointer

SKIP  ( char -- )  skip over any bytes in TIB that equal (char)
SCAN  ( char -- )  scan TIB until (char) is found in TIB

+CHAR  ( -- )
PARSE  ( char -- )  copy all bytes upto (char) to HERE

WORD  ( char -- )  copy all bytes upto (char) to HERE skipping
	leading characters
(  ( -- )  skip all characters upto and including ')'
COMPILE  ( addr -- )

( ==== Strings ==== )
QUOTE  ( -- )
(")  ( -- addr )  primitive for "
"  ( -- )  return the address of a count prefixed string delimited by "
(.")  ( -- )  primitive for ."
."  ( -- )  print all characters upto "

( ==== Errors ==== )
SP!  ( ? -- )  initialize parameter stack pointer
RP!  ( -- )  initialize return stack pointer

ABORT  ( -- )  reset the return stack
ERROR  ( -- )  printout any string at HERE and ABORT
?ERROR  ( flag -- )  call ERROR if (flag) is non-zero

( ==== Number Conversion ==== )
DIGIT  ( char -- n \ flag )  convert (char) to digit, return n\YES if 
(char)
	is a hex digit else junk\NO
NUMBER  ( string -- n )  convert HEX (string) into (n)
XQUOTE  ( -- )  primitive used by X"
X"  ( -- )  return address of count prefixed HEX string
T"  ( -- )  create a table of values named by next word in input stream

( ==== Dictionary Searching ==== )
C>LINK  ( code -- link )  convert a Code Field Address to a Link Field 
Address
L>CODE  ( link -- code )  convert a Link Field Address to a Code Field 
Address

COMPARE  ( string \ name -- flag )  compare a string to a name field
SEARCH?  ( string \ >list -- addr \ nc | -- string \ no ) search list for 
string

FIND?  ( -- addr \ nc | -- string \ no )  try to find next word from
	input stream
?FIND  ( -- addr )  try to find next word in input stream or fail trying

( ==== Interpreter ==== )

LITERAL  ( n -- )  lay down (n) in memory if in compile mode
'  ( -- cfa )  return code field address of next word in input stream

INTERPRET  ( -- )

( ==== Key collector ==== )
PROMPT  ( -- )  output prompt to screen
PREPARE  ( key -- key )
COLLECTOR  ( -- )

( ==== New control loop ==== )
RESET-INPUT  ( -- )

QUIT  ( -- )  give up and do soft-reboot

TOG  ( -- )  toggle PROG and DATA memory maps between BBRAM and SRAM
LOAD  ( -- )  copy BBRAM into SRAM
SAVE  ( -- )  copy SRAM into BBRAM
MAP?  ( -- )  display PROG and DATA memory maps

INIT  ( -- )  initialize 8051

( ==== Conditionals ==== )
(DO)  ( limit \ index -- )  primitive used by DO
(LOOP)  ( -- )  primitive used by LOOP
(+LOOP)  ( n -- )  primitive used by +LOOP

IF  ( -- addr ),( n -- )  execute words after IF if (n) is not 0
ENDIF  ( addr -- ),( -- )  end of IF construct
ELSE  ( addr -- addr ),( -- )  execute words after IF if (n) was 0
THEN  ( addr -- ),( -- )  same as ENDIF

BEGIN  ( -- addr ),( -- )  beginning of repeated structure
WHILE  ( -- addr ),( n -- )  execute following words if (n) is not 0
AGAIN  ( addr -- ),( -- )  branch back to begin
REPEAT  ( addr \ addr -- ),( -- )  branch back to begin
UNTIL  ( addr -- ),( n -- )  branch back to begin if (n) is 0

FOR  ( -- addr \ addr ),( n -- )  repeat words until NEXT n times 
	( n-1 to 0 inclusive )
NEXT  ( addr \ addr -- ),( -- )  delimit FOR-NEXT loop

DO  ( -- addr ),( limit \ index -- )
LOOP  ( addr -- ),( -- )
+LOOP  ( addr -- ),( n -- )
LEAVE  ( -- )  clean exit from DO-LOOP

CASE  ( -- )
{  ( -- )
}  ( -- )
ENDCASE  ( -- )

( ==== Defining Words ==== )
EXIT  ( -- )  exit current word
FORGET ( -- )  forget all definitions after and including the next input word
?UNIQUE  ( -- )
CREATE  ( -- )  create an entry in the dictionary for the next input word

<BUILDS  ( -- )  create a word and have it return the address
	of space after it
DOES  ( -- )  set latest word to execute code after DOES then return
DOES>  ( -- addr )  same as DOES except leaves child's address on stack

VARIABLE  ( val -- )  create a variable and initialize it to (val)
CONSTANT  ( val -- )  create a constant equal to (val)
TABLE  ( -- )  create a table with values that follow

:  ( -- )  start a word definition
;  ( -- )  terminate a word definition

QUEUE  ( #words -- ) ( Queues: | >insert | >remove | >end | queue... | )

( ==== File Loader: FF emitted to request a line of input ==== )
INPUT-LINE  ( -- )
LD  ( -- )

( ==== Version ==== )
VERSION  ( -- )  display version

( ==== End of kernel ==== )

( ==== Tools ==== )
0 VARIABLE blatest    ( latest branch address )
IN-WHAT  ( addr -- lfa )  return (lfa) of word that (addr) resides in
.NAME  ( lfa -- )  output name of word corresponding to (lfa)
.WORD  ( addr -- addr+ )
?DIR  ( addr -- addr+ )
.CODE  ( n \ addr -- addr+ )
SEE  ( -- )  decompile the next word in the input stream
WORDS  ( -- )  list all words compiled in the dictionary
WHERE  ( addr -- )  output name of the word that resides over (addr)

.S  ( -- )

.H  ( n -- )  emit top item as 4 HEX characters ( 16 bit )
C.H  ( b -- )  emit top item as 2 HEX characters ( 8 bit )
?ASCII  ( b -- b )  returns same if top item is ASCII else returns '.'
DUMP  ( addr \ n -- )  dump (n) bytes of memory staring at (addr) to screen


